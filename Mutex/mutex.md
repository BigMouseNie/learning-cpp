# `futex` 的整体工作流程

**完整的 `futex` 锁获取流程：**

1. **尝试原子获取锁（用户态）**
    - `atomic_exchange(&lock, 1)`，如果成功，锁定成功，立即返回。
    - 如果失败（锁已被占用），进入步骤 2。
    
2. **用户态自旋等待**
    - 线程会短时间内 **自旋等待**，看看锁是否释放。
    - **如果锁很快释放**，直接获取，避免 `syscall`。
    - **如果锁长时间未释放**（例如 1000 次循环后），进入步骤 3。
        
3. **进入内核等待**
    - `futex_wait(&lock, 1)`，线程进入 **内核态，挂起等待锁**。
        
4. **锁释放时，唤醒等待线程**
    - `futex_wake(&lock, 1)`，内核唤醒一个等待的线程。
    - 线程重新回到 **用户态** 竞争锁。


# `Linux glibc` 实现

1. **`lock` 过程**
	- 用户层：比较 `_lock` 是否为0
		如果是0，设置为1；加锁成功
		如果是1，则设置为2；并 `futex_wait`；
		如果是2，则 `futex_wait`；
		说明：
	- 内核层
		系统调用 `futex_wait` 后，加入等待队列，阻塞等待 

2. **`unlock` 过程**
	- 用户层：比较 `_lock` 的值
		如果是1，没有竞争，设置为0，解锁成功
		如果是2，有竞争，设置为1，`futex_wake`
	- 内核态
		系统调用 `futex_wake` 后，从等待队列中选择线程唤醒
